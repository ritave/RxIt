{"version":3,"file":"source.js","sourceRoot":"","sources":["../src/source.ts"],"names":[],"mappings":";;;AAuBA,QAAe,CAAC,CAAC,KAAK,CAAC,KAAa,EAAE,KAAc;IAClD,IAAI,EAAE,GAAG,KAAK,CAAC;IACf,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,KAAK,KAAK,SAAS,IAAI,CAAC,GAAG,KAAK,EAAE;QACvC,MAAM,EAAE,CAAC;QACT,EAAE,IAAI,CAAC,CAAC;QACR,CAAC,IAAI,CAAC,CAAC;KACR;AACH,CAAC;AARD,sBAQC;AAaD,QAAe,CAAC,CAAC,QAAQ,CACvB,OAAuD;;IAEvD,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC;IACjC,OAAO,MAAA,MAAA,OAAO,CAAC,SAAS,wDAAG,KAAK,EAAE,CAAC,CAAC,mCAAI,IAAI,EAAE;QAC5C,IAAI,gBAAgB,IAAI,OAAO,EAAE;YAC/B,MAAM,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SACxC;aAAM;YACL,MAAM,KAAK,CAAC;SACb;QACD,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAClC,CAAC,IAAI,CAAC,CAAC;KACR;AACH,CAAC;AAdD,4BAcC;AAED,QAAe,CAAC,CAAC,IAAI,CAAI,KAAQ;IAC/B,MAAM,KAAK,CAAC;AACd,CAAC;AAFD,oBAEC","sourcesContent":["/**\n * Creates an iterator that emits values from `start` indefinitely.\n *\n * ```text\n * range(3)\n * -3--4--5--6--...\n * ```\n *\n * @param start - Initial value.\n */\nexport function range(start: number): Iterable<number>;\n/**\n * Creates an iterator that emits `count` values, starting from `start`.\n *\n * ```text\n * range(1, 5)\n * -1--2--3--4--5-|>\n * ```\n *\n * @param start - Initial value.\n * @param count - How many values to emit.\n */\nexport function range(start: number, count: number): Iterable<number>;\nexport function* range(start: number, count?: number) {\n  let at = start;\n  let i = 0;\n  while (count === undefined || i < count) {\n    yield at;\n    at += 1;\n    i += 1;\n  }\n}\n\nexport interface GenerateBaseOptions<A> {\n  initialState: A;\n  iterate: (value: A, index: number) => A;\n  condition?: (value: A, index: number) => boolean;\n}\nexport interface GenerateOptions<A, T> extends GenerateBaseOptions<A> {\n  resultSelector: (value: A, index: number) => T;\n}\n\nexport function generate<A>(options: GenerateBaseOptions<A>): Iterable<A>;\nexport function generate<A, T>(options: GenerateOptions<A, T>): Iterable<T>;\nexport function* generate<A, T>(\n  options: GenerateBaseOptions<A> | GenerateOptions<A, T>,\n): Iterable<A | T> {\n  let i = 0;\n  let state = options.initialState;\n  while (options.condition?.(state, i) ?? true) {\n    if ('resultSelector' in options) {\n      yield options.resultSelector(state, i);\n    } else {\n      yield state;\n    }\n    state = options.iterate(state, i);\n    i += 1;\n  }\n}\n\nexport function* just<A>(value: A): Iterable<A> {\n  yield value;\n}\n"]}