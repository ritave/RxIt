{"version":3,"file":"sink.js","sourceRoot":"","sources":["../src/sink.ts"],"names":[],"mappings":";;;AAAA,2CAAuD;AAEvD;;;;;;;;;;GAUG;AACI,MAAM,OAAO,GAAG,CAAI,MAAyC,EAAE,EAAE,CACtE,UAAU,EAAe;IACvB,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,KAAK,MAAM,EAAE,IAAI,EAAE,EAAE;QACnB,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;QACd,CAAC,IAAI,CAAC,CAAC;KACR;AACH,CAAC,CAAC;AAPS,QAAA,OAAO,WAOhB;AAEJ;;;;;;;;;GASG;AACI,MAAM,MAAM,GAAG,GAAG,EAAE,CACzB,UAAa,EAAe;IAC1B,OAAO,CAAC,GAAG,IAAA,kBAAM,GAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC;AAHS,QAAA,MAAM,UAGf;AAEJ;;;;;;;;;;GAUG;AACI,MAAM,WAAW,GAAG,GAAG,EAAE,CAC9B,UAAa,EAAe;IAC1B,MAAM,IAAI,GAAG,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;IAC1C,IAAI,IAAI,CAAC,IAAI,EAAE;QACb,MAAM,IAAI,SAAS,CAAC,oDAAoD,CAAC,CAAC;KAC3E;IACD,OAAO,IAAI,CAAC,KAAK,CAAC;AACpB,CAAC,CAAC;AAPS,QAAA,WAAW,eAOpB;AAsBJ;;;;;;GAMG;AACH,SAAgB,YAAY,CAC1B,GAAG,IAA4C;IAE/C,OAAO,UAAU,EAAe;QAC9B,IAAI,OAAO,CAAC;QACZ,gDAAgD;QAChD,8EAA8E;QAC9E,QAAQ,IAAI,CAAC,MAAM,EAAE;YACnB,KAAK,CAAC;gBACJ,OAAO,GAAG,IAAA,cAAM,GAAE,CAAC,IAAA,kBAAM,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACxC,MAAM;YACR,KAAK,CAAC;gBACJ,OAAO,GAAG,IAAA,cAAM,GAAE,CAAC,IAAA,kBAAM,EAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACjD,MAAM;YACR,qBAAqB;YACrB;gBACE,CAAC,CAAC,CAAQ,EAAE,EAAE;oBACZ,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YACX,mBAAmB;SACpB;QAED,IAAI,OAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACzB,MAAM,IAAI,SAAS,CAAC,kDAAkD,CAAC,CAAC;SACzE;QACD,OAAO,OAAQ,CAAC,CAAC,CAAC,CAAC;IACrB,CAAC,CAAC;AACJ,CAAC;AA3BD,oCA2BC","sourcesContent":["import { buffer, reduce, ReduceFn } from './transform';\n\n/**\n * Consumes an iterator calling a side-effect function on each emitted value.\n *\n * @example\n * ```\n * pipe([1, 2, 3], map(x => x * 2), forEach(console.log))\n * ```\n *\n * @param effect - The function call on each upstream value.\n * @returns Nothing, consumes the upstream iterator\n */\nexport const forEach = <A>(effect: (input: A, index: number) => void) =>\n  function (it: Iterable<A>) {\n    let i = 0;\n    for (const el of it) {\n      effect(el, i);\n      i += 1;\n    }\n  };\n\n/**\n * Takes an iterator and returns all elements as an array.\n *\n * @example\n * ```\n * pipe([1, 2, 3], map(v => v * 2), unwrap());\n * // returns [2, 4, 6]\n * ```\n * @returns An array of all elements in the iterator.\n */\nexport const unwrap = () =>\n  function <A>(it: Iterable<A>) {\n    return [...buffer()(it)][0];\n  };\n\n/**\n * Takes an iterator and returns the first element.\n *\n * @example\n * ```typescript\n * pipe([1, 2, 3], map(v => v * 2), unwrapFirst());\n * // returns \"2\"\n * ```\n * @throws {@link TypeError}. In case the upstream was empty.\n * @returns The first element returned by the iterator.\n */\nexport const unwrapFirst = () =>\n  function <A>(it: Iterable<A>) {\n    const next = it[Symbol.iterator]().next();\n    if (next.done) {\n      throw new TypeError('Tried to unwrap first element from empty iterator.');\n    }\n    return next.value;\n  };\n\n/**\n * Takes an iterator, reduces it's values using standard semantics of array.reduce and returns a single value.\n *\n * @throws {@link TypeError}. In case the upstream was empty.\n * @param fn - Standard array.reduce reducer.\n * @returns Single reduced value.\n */\nexport function unwrapReduce<A>(fn: ReduceFn<A, A>): (_: Iterable<A>) => A;\n/**\n * Takes an iterator, reduces it's values using standard semantics of array.reduce and returns a single value.\n *\n * @throws {@link TypeError}. In case the upstream was empty.\n * @param fn - Standard array.reduce reducer.\n * @param initial - Initial value passed down to `fn` as accumulator.\n * @returns A single reduced value.\n */\nexport function unwrapReduce<A, U>(\n  fn: ReduceFn<A, U>,\n  initial: U,\n): (_: Iterable<A>) => U;\n/**\n * Takes an iterator, reduces it's values using standard semantics of array.reduce and returns a single value.\n *\n * @throws {@link TypeError}. In case the upstream was empty.\n * @param args - Standard array.reduce arguments.\n * @returns A single reduced value.\n */\nexport function unwrapReduce<A, U>(\n  ...args: [ReduceFn<A, A>] | [ReduceFn<A, U>, U]\n) {\n  return function (it: Iterable<A>) {\n    let reduced;\n    // reduce can pass `undefined` as initial value.\n    // It uses number of arguments to discern whether undefined was passed or not.\n    switch (args.length) {\n      case 1:\n        reduced = unwrap()(reduce(args[0])(it));\n        break;\n      case 2:\n        reduced = unwrap()(reduce(args[0], args[1])(it));\n        break;\n      /* c8 ignore start */\n      default:\n        ((_: never) => {\n          throw new Error('Unreachable');\n        })(args);\n      /* c8 ignore end */\n    }\n\n    if (reduced!.length !== 1) {\n      throw new TypeError('Reduce with no initial value and empty upstream.');\n    }\n    return reduced![0];\n  };\n}\n"]}